#pragma once

#ifndef _G3D_TILE_H_
#define _G3D_TILE_H_


#include <map>
#include "gdelegatedefine.h"
#include "g3dtiledefine.h"
#include "g3dtilerecord.h"
#include "g3dtilegeometry.h"
#include "g3dtilespatial.h"
#include "g3dtilecontent.h"
#include "g3dtilestructuretree.h"
#include "g3dtilestorage.h"
#include "g3dtilelayer.h"
#include "g3dtileinfo.h"

namespace MapGIS
{
	namespace Tile
	{
		//================================================================================
		/// 瓦片添加模式（目前仅在生成3dTiles缓存时有作用）
		/// 定义了几种不同的瓦片组织和存储策略
		//================================================================================
		enum class TileAppendMode :int
		{
			//================================================================================
			/// 自动模式（根据四叉树和八叉树类型，分别按6级和4级将子节点放入子文件夹，并且创建子树）
			/// 这是默认的智能组织模式，会自动创建文件夹结构和子树结构
			//================================================================================
			AutoMode = 0,

			//================================================================================
			/// 自动模式2（根据四叉树和八叉树类型，分别按6级和4级组织创建子文件夹，但是不创建子树）
			/// 只创建文件夹层次结构，不创建子树数据结构
			//================================================================================
			AutoMode2 = 1,

			//================================================================================
			/// 自动模式3（根据四叉树和八叉树类型，分别按6级和4级组织创建子树，但是不创建子文件夹）
			/// 只创建子树数据结构，不创建物理文件夹结构
			//================================================================================
			AutoMode3 = 2,

			//================================================================================
			/// 创建一个子树，且创建子文件夹
			/// 强制创建完整的子树和文件夹结构
			//================================================================================
			CreateSubTree = 3,

			//================================================================================
			/// 不创建一个子树，不创建子文件夹
			/// 不进行任何子结构的创建，保持扁平结构
			//================================================================================
			DoNotSubTree = 4,
		};

		//================================================================================
		/// 属性存放类型
		/// 定义了几何对象属性数据的存储方式
		//================================================================================
		enum class AttributeType :int
		{
			//================================================================================
			/// 默认文件存储方式
			/// 属性数据以独立文件形式存储（如.att文件）
			//================================================================================
			DefaultFile = 0,

			//================================================================================
			/// SQLite数据库存储方式
			/// 属性数据存储在SQLite数据库中，与.mcj文件在同一文件夹下生成一个SQLite数据库文件
			//================================================================================
			SqliteFile,  // 数据库，与mcj同文件夹生成一个sqlite数据库，属性存放到内部
		};

		//================================================================================
		/// 写入内容参数基类
		/// 所有写入参数类的抽象基类，定义了通用接口
		//================================================================================
		class MAPGISG3DTILEEXPORT WriteContentParamBase
		{
		public:
			// 默认构造函数
			WriteContentParamBase() = default;

			// 虚析构函数，确保派生类能正确析构
			virtual ~WriteContentParamBase() = default;

			//================================================================================
			/// 获取数据类型
			///
			/// @return 数据类型枚举值
			//================================================================================
			virtual DataType GetDataType() = 0;
		};

		//================================================================================
		/// 几何内容写入参数类
		/// 用于配置几何模型数据的写入参数
		//================================================================================
		class MAPGISG3DTILEEXPORT WriteGeometryContentParam : public WriteContentParamBase
		{
		public:
			//================================================================================
			/// 默认构造函数
			/// 初始化所有参数为默认值
			//================================================================================
			WriteGeometryContentParam()
			{
				geoCompressType = GeoCompressType::None;  // 默认不压缩
				dataType = DataType::Model;               // 默认为模型数据类型
				attInContent = false;                     // 默认属性不存储在瓦片内部
				attributeType = AttributeType::DefaultFile; // 默认属性存储方式为文件存储
			}

			// 虚析构函数
			virtual ~WriteGeometryContentParam() = default;

			//================================================================================
			/// 获取数据类型
			///
			/// @return 当前设置的数据类型
			//================================================================================
			virtual DataType GetDataType() override { return dataType; }

			//================================================================================
			/// 设置数据类型
			///
			/// @param [in] type 要设置的数据类型
			//================================================================================
			void SetDataType(DataType type) { dataType = type; }

			//================================================================================
			/// 获取几何压缩类型
			/// M3D2.0及以上版本有效
			///
			/// @return 当前设置的几何压缩类型
			//================================================================================
			virtual GeoCompressType GetGeoCompressType() { return geoCompressType; }

			//================================================================================
			/// 设置几何压缩类型
			/// M3D2.0及以上版本有效
			///
			/// @param [in] type 要设置的几何压缩类型
			//================================================================================
			void SetGeoCompressType(GeoCompressType type) { geoCompressType = type; }

			//================================================================================
			/// 判断属性是否写在瓦片内部
			/// M3D2.1及以上版本有效
			///
			/// @return 属性存储位置标志
			///         - true: 属性存储在瓦片内容内部
			///         - false: 属性独立存储
			//================================================================================
			virtual bool IsAttInContent() { return attInContent; }

			//================================================================================
			/// 设置属性是否写在瓦片内部
			/// M3D2.1及以上版本有效
			///
			/// @param [in] inContent 属性存储位置标志
			///                   - true: 存储在瓦片内部
			///                   - false: 独立存储
			//================================================================================
			void SetAttInContent(bool inContent) { attInContent = inContent; }

			//================================================================================
			/// 获取属性类型
			/// M3D2.2版本起有效
			///
			/// @return 当前设置的属性存储类型
			///         - AttributeType::DefaultFile: 存储为.att文件，attInContent参数有效
			///         - AttributeType::SqliteFile: 存储为SQLite文件，attInContent参数无效
			///
			/// @note 如果设置为AttributeType::SqliteFile，则在开始写入Content前需要调用G3DTileset::StartWriteSqlite，
			///       所有Content写完之后调用G3DTileset::EndtWriteSqlite，
			///       并且G3DTile内的G3DCacheStorage与G3DTileset内的G3DCacheStorage保持一致。
			//================================================================================
			virtual AttributeType GetAttributeType() { return attributeType; }

			//================================================================================
			/// 设置属性类型
			/// M3D2.2版本起有效
			///
			/// @param [in] type 要设置的属性存储类型
			//================================================================================
			void SetAttributeType(AttributeType type) { attributeType = type; }

		private:
			GeoCompressType  geoCompressType;  // 几何压缩类型
			DataType dataType;                 // 数据类型
			bool attInContent;                 // 属性是否存储在瓦片内部
			AttributeType attributeType;       // 属性存储类型
		};

		//================================================================================
		/// 体素内容写入参数类
		/// 用于配置体素数据的写入参数
		//================================================================================
		class MAPGISG3DTILEEXPORT WriteVoxelContentParam : public WriteContentParamBase
		{
		public:
			//================================================================================
			/// 默认构造函数
			//================================================================================
			WriteVoxelContentParam() = default;

			// 虚析构函数
			virtual ~WriteVoxelContentParam() = default;

			//================================================================================
			/// 获取数据类型
			///
			/// @return DataType::Voxel（体素数据类型）
			//================================================================================
			virtual DataType GetDataType() override { return DataType::Voxel; }
		};

		//================================================================================
		/// 高斯点阵内容写入参数类
		/// 用于配置高斯点阵数据的写入参数
		//================================================================================
		class MAPGISG3DTILEEXPORT WriteGaussianContentParam : public WriteContentParamBase
		{
		public:
			//================================================================================
			/// 默认构造函数
			//================================================================================
			WriteGaussianContentParam()
			{
				mode = GaussianExtMode::KHRGaussianSplattingCompressionSpz2;  // 默认无扩展模式
			}

			// 虚析构函数
			virtual ~WriteGaussianContentParam() = default;

			//================================================================================
			/// 获取数据类型
			///
			/// @return DataType::GaussianSplatting（高斯点阵数据类型）
			//================================================================================
			virtual DataType GetDataType() override { return DataType::GaussianSplatting; }

			//================================================================================
			/// 获取高斯数据扩展模式
			///
			/// @return 当前设置的高斯数据扩展模式
			//================================================================================
			virtual GaussianExtMode GetGaussianExtMode() { return mode; }

			//================================================================================
			/// 设置高斯数据扩展模式
			///
			/// @param [in] type 要设置的高斯数据扩展模式
			//================================================================================
			void SetGaussianExtMode(GaussianExtMode type) { mode = type; }

		private:
			GaussianExtMode mode;  // 高斯数据扩展模式
		};

		//================================================================================
		/// 三维缓存切片（节点）类
		/// 表示M3D结构中的一个切片节点，包含几何数据、元数据和子节点信息
		//================================================================================
		class MAPGISG3DTILEEXPORT G3DTile
		{
		protected:
			//================================================================================
			/// 默认构造函数（受保护）
			/// 仅允许派生类调用，防止直接实例化基类
			//================================================================================
			G3DTile() = default;

		public:
			//================================================================================
			/// 虚析构函数
			/// 确保派生类能够正确析构，支持多态删除
			//================================================================================
			virtual ~G3DTile() = default;

			//================================================================================
			/// 设置切片名称
			///
			/// @param [in] tileName 要设置的切片名称
			///
			/// @remark 用于标识切片的可读名称，便于管理和调试
			//================================================================================
			virtual void SetName(CGString tileName) = 0;

			//================================================================================
			/// 获取切片名称
			///
			/// @return 当前切片的名称
			//================================================================================
			virtual CGString GetName() = 0;

			//================================================================================
			/// 设置切片外包范围（包围盒）
			///
			/// @param [in] bounding 要设置的外包范围对象
			///
			/// @remark 外包范围用于空间查询和视锥体剔除优化
			//================================================================================
			virtual void SetBounding(MapGIS::Tile::BoundingVolume& bounding) = 0;

			//================================================================================
			/// 获取切片外包范围（包围盒）
			///
			/// @return 当前切片的外包范围对象
			//================================================================================
			virtual MapGIS::Tile::BoundingVolume GetBounding() = 0;

			//================================================================================
			/// 设置几何误差
			///
			/// @param [in] geometricError 要设置的几何误差值
			///
			/// @remark 几何误差用于控制细节层次(LOD)的切换，
			///         表示从当前切片切换到子切片时允许的最大几何误差
			//================================================================================
			virtual void SetGeometricError(float geometricError) = 0;

			//================================================================================
			/// 获取几何误差
			///
			/// @return 当前切片的几何误差值
			//================================================================================
			virtual float GetGeometricError() = 0;

			//================================================================================
			/// 设置切片细化模式
			///
			/// @param [in] refine 要设置的细化模式枚举值
			///
			/// @remark RefineType::ADD 表示添加细化（显示当前切片和子切片），
			///         RefineType::REPLACE 表示替换细化（用子切片替换当前切片）
			//================================================================================
			virtual void SetRefine(MapGIS::Tile::RefineType refine) = 0;

			//================================================================================
			/// 获取切片细化模式
			///
			/// @return 当前切片的细化模式枚举值
			//================================================================================
			virtual MapGIS::Tile::RefineType GetRefine() = 0;

			//================================================================================
			/// 设置转换矩阵
			///
			/// @param [in] matrix 要设置的4x4转换矩阵
			///
			/// @remark 用于定义切片内容的局部坐标系变换到父坐标系的变换矩阵
			//================================================================================
			virtual void SetMatrix(MapGIS::Tile::Matrix4D matrix) = 0;

			//================================================================================
			/// 获取转换矩阵
			///
			/// @return 当前切片的转换矩阵
			//================================================================================
			virtual MapGIS::Tile::Matrix4D GetMatrix() = 0;

			//================================================================================
			/// 判断是否为根节点
			///
			/// @return 节点类型标识
			///         - true: 当前节点为根节点
			///         - false: 当前节点为子节点
			//================================================================================
			virtual bool IsRoot() = 0;

			//================================================================================
			/// 添加子节点
			///
			/// @param [in] mode 子节点添加模式（默认为自动模式）
			///
			/// @return 新创建的子节点对象指针
			///         - 成功：指向新创建的子节点对象
			///         - 失败：返回nullptr
			///
			/// @remark 返回的子节点对象由调用者负责管理内存
			//================================================================================
			virtual G3DTile* AppendChild(TileAppendMode mode = TileAppendMode::AutoMode) = 0;

			//================================================================================
			/// 根据节点指针删除子节点
			///
			/// @param [in] pChildTile 要删除的子节点对象指针
			///
			/// @return 操作结果
			///         - gisLONG > 0：删除成功
			///         - gisLONG <= 0：删除失败
			//================================================================================
			virtual gisLONG RemoveChild(G3DTile* pChildTile) = 0;

			//================================================================================
			/// 获取子节点数量
			///
			/// @return 当前节点包含的直接子节点个数
			//================================================================================
			virtual gisLONG GetChildNum() = 0;

			//================================================================================
			/// 根据索引获取子节点
			///
			/// @param [in] index 子节点索引号（从0开始）
			///
			/// @return 指定索引的子节点对象指针
			///         - 成功：指向对应的子节点对象
			///         - 失败（索引越界）：返回nullptr
			//================================================================================
			virtual G3DTile* GetChild(int index) = 0;

			//================================================================================
			/// 根据索引删除子节点
			///
			/// @param [in] index 要删除的子节点索引号（从0开始）
			///
			/// @return 操作结果
			///         - gisLONG > 0：删除成功
			///         - gisLONG <= 0：删除失败
			//================================================================================
			virtual gisLONG RemoveChild(int index) = 0;

			//================================================================================
			/// 递归释放所有子节点对象
			///
			/// @remark 该方法会递归遍历并释放当前节点下所有层级的子节点和孙节点对象，
			///         防止内存泄漏，通常在析构根节点时调用
			//================================================================================
			virtual void ReleaseChildObjects() = 0;

			//================================================================================
			/// 获取切片内容信息
			///
			/// @return 当前切片的内容信息对象
			///
			/// @remark 内容信息包括内容URI、内容类型等元数据
			//================================================================================
			virtual TileContentInfo GetContentInfo() = 0;

			//================================================================================
			/// 获取切片详细信息
			///
			/// @return 当前切片的详细信息对象指针
			///
			/// @remark 返回的对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			virtual G3DTileInfo* GetInfo() = 0;

			//================================================================================
			/// 写入数据内容到切片
			///
			/// @param [in] contentName  内容名称
			/// @param [in] pContents    内容数据列表（ContentBase对象数组）
			/// @param [in] param        写入内容所需的参数配置对象
			///
			/// @return 操作结果
			///         - gisLONG > 0：写入成功
			///         - gisLONG <= 0：写入失败
			///
			/// @remark 对于体元栅格/高斯数据只支持1个ContentBase数据
			//================================================================================
			virtual gisLONG WriteContent(CGString contentName, vector<ContentBase*>* pContents, WriteContentParamBase& param) = 0;

			//================================================================================
			/// 从切片读取数据内容
			///
			/// @param [out] pContents 内容数据列表（需要外部销毁ContentBase*对象）
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 读取的内容对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			virtual gisLONG ReadContent(vector<ContentBase*>* pContents) = 0;

			//================================================================================
			/// 从存储中打开指定切片
			///
			/// @param [in]  pCacheStorage 存储对象指针
			/// @param [in]  relativePath  切片相对路径
			/// @param [in]  cacheType     缓存类型枚举值
			///
			/// @return 切片对象指针
			///         - 成功：指向打开的G3DTile对象
			///         - 失败：返回nullptr
			///
			/// @remark 返回的Tile对象需要外部调用delete进行释放
			//================================================================================
			static G3DTile* Open(G3DCacheStorage* pCacheStorage, CGString relativePath, G3DCacheType cacheType);

			//================================================================================
			/// 获取切片相对路径
			///
			/// @return 切片的相对路径字符串
			///
			/// @remark 如果该切片能够保存为一个独立文件，则返回其相对路径，
			///         否则返回空字符串对象
			//================================================================================
			virtual CGString GetRelativePath() const = 0;

			//================================================================================
			/// 保存切片及其子节点
			///
			/// @return 操作结果
			///         - gisLONG > 0：保存成功
			///         - gisLONG <= 0：保存失败
			///
			/// @remark 保存当前切片的JSON元数据内容，同时递归保存所有子节点的JSON内容
			//================================================================================
			virtual gisLONG Save() = 0;

			//================================================================================
			/// 关闭切片
			///
			/// @remark 仅适用于通过Open()方法打开的切片，用于释放相关资源。
			///         通过AppendChild()方法添加的子节点不应调用此方法。
			//================================================================================
			virtual void Close() = 0;

			//================================================================================
			/// 获取缓存储存对象
			///
			/// @return 当前切片关联的缓存储存对象指针
			//================================================================================
			virtual G3DCacheStorage* GetCacheStorage() = 0;
		};

		//================================================================================
		/// 三维缓存切片集类
		/// 表示一个完整的3D Tiles数据集，包含根节点、元数据和全局属性信息
		//================================================================================
		class MAPGISG3DTILEEXPORT G3DTileset
		{
		protected:
			//================================================================================
			/// 默认构造函数（受保护）
			/// 仅允许派生类调用，防止直接实例化基类
			//================================================================================
			G3DTileset() = default;

		public:
			//================================================================================
			/// 虚析构函数
			/// 确保派生类能够正确析构，支持多态删除
			//================================================================================
			virtual ~G3DTileset() = default;

			//================================================================================
			/// 创建Tileset实例对象
			///
			/// @param [in] cacheType 缓存类型枚举值
			///
			/// @return Tileset对象指针
			///         - 成功：指向新创建的缓存集对象
			///         - 失败：返回nullptr
			///
			/// @remark 返回的Tileset对象需要外部调用delete进行释放
			//================================================================================
			static G3DTileset* CreateInstance(G3DCacheType cacheType);

			//================================================================================
			/// 创建新的Tileset数据集
			///
			/// @param [in] pCacheStorage 缓存储存对象指针
			/// @param [in] tilesetName   要创建的tileset名称
			///
			/// @return 操作结果
			///         - gisLONG > 0：创建成功
			///         - gisLONG <= 0：创建失败
			///
			/// @remark 创建成功后，可以通过IsValid()方法检查是否有效
			//================================================================================
			virtual gisLONG Create(G3DCacheStorage* pCacheStorage, CGString tilesetName) = 0;

			//================================================================================
			/// 打开已存在的Tileset数据集
			///
			/// @param [in] pCacheStorage 缓存储存对象指针
			/// @param [in] tilesetName   要打开的tileset名称
			///
			/// @return 操作结果
			///         - gisLONG > 0：打开成功
			///         - gisLONG <= 0：打开失败
			///
			/// @remark 打开成功后，可以通过IsValid()方法检查是否有效
			//================================================================================
			virtual gisLONG Open(G3DCacheStorage* pCacheStorage, CGString tilesetName) = 0;

			//================================================================================
			/// 保存Tileset数据集
			///
			/// @return 操作结果
			///         - gisLONG > 0：保存成功
			///         - gisLONG <= 0：保存失败
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG Save() = 0;

			//================================================================================
			/// 关闭Tileset数据集
			///
			/// @return 操作结果
			///         - gisLONG > 0：关闭成功
			///         - gisLONG <= 0：关闭失败
			///
			/// @remark 关闭后应释放相关资源
			//================================================================================
			virtual gisLONG Close() = 0;

			//================================================================================
			/// 检查Tileset对象是否有效
			///
			/// @return 有效性标识
			///         - true：tileset对象有效（通过create()或open()成功创建/打开）
			///         - false：tileset对象无效
			///
			/// @remark 当tileset对象通过create()成功创建或者通过open()成功打开时，
			///         IsValid()返回true，否则返回false
			//================================================================================
			virtual bool IsValid() = 0;

			//================================================================================
			/// 设置图层字段信息
			///
			/// @param [in] pLayersInfo 图层字段信息对象指针
			///
			/// @return 操作结果
			///         - gisLONG > 0：设置成功
			///         - gisLONG <= 0：设置失败
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG SetLayerFieldsInfo(const LayersInfoBase* pLayersInfo) = 0;

			//================================================================================
			/// 清除图层字段信息
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual void ClearLayerFieldsInfo() = 0;

			//================================================================================
			/// 获取图层字段信息
			///
			/// @param [in] pLayersInfo 用于接收图层字段信息的对象指针
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG GetLayerFieldsInfo(LayersInfoBase* pLayersInfo) = 0;

			//================================================================================
			/// 获取缓存储存对象
			///
			/// @return 当前Tileset关联的缓存储存对象指针
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual G3DCacheStorage* GetCacheStorage() = 0;

			//================================================================================
			/// 获取Tileset的根节点
			///
			/// @return 根节点对象指针
			///         - 成功：指向G3DTile根节点对象
			///         - 失败：返回nullptr
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual G3DTile* GetRoot() = 0;

			//================================================================================
			/// 设置Tileset的全局唯一标识符
			///
			/// @param [in] guid 要设置的GUID值
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual void SetGUID(GUID guid) = 0;

			//================================================================================
			/// 获取Tileset的全局唯一标识符
			///
			/// @return 当前Tileset的GUID值
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual GUID GetGUID() = 0;

			//================================================================================
			/// 设置Tileset的定位点坐标
			///
			/// @param [in] dot 要设置的定位点三维坐标
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual void SetPosition(D_3DOT dot) = 0;

			//================================================================================
			/// 获取Tileset的定位点坐标
			///
			/// @return 当前Tileset的定位点三维坐标
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual D_3DOT GetPosition() = 0;

			//================================================================================
			/// 设置目录树类型
			///
			/// @param [in] treeType 要设置的目录树类型枚举值
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual void SetTreeType(TreeType treeType) = 0;

			//================================================================================
			/// 获取目录树类型
			///
			/// @return 当前Tileset的目录树类型枚举值
			///
			/// @remark 仅当IsValid()为true时该方法有效
			//================================================================================
			virtual TreeType GetTreeType() = 0;

			//================================================================================
			/// 开始写入属性到SQLite数据库中,在tile调用WriteContent之前调用，会将content中的属性写入SQLite数据库中。
			///
			/// @return 操作结果
			///         - gisLONG > 0：操作成功
			///         - gisLONG <= 0：操作失败
			///
			/// @remark 仅对M3D2.2及以上版本有效，在调用Save()之后才可调用EndWriteSqlite()，
			///         否则不会实际写入到数据库中。仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG StartWriteSqlite() = 0;


			//================================================================================
			/// 设置SQLite数据库中的包围盒信息
			/// 将TID与对应包围盒信息的映射关系写入SQLite数据库中
			///
			/// @param [in] tid2Box TID到包围盒信息的映射表，其中：
			///                     - key (gisINT64): TID标识符
			///                     - value (vector<double>):笛卡尔坐标系下的包围盒信息，包含6个值表示(xmin, ymin, zmin, xmax, ymax, zmax),
			///
			/// @remark 此方法用于在M3D 2.2及以上版本中，将几何体的包围盒信息存储到SQLite数据库中，
			///         以便快速空间查询和LOD处理。需要在Save()之前调用。
			///         仅当IsValid()返回true时此方法有效。
			//================================================================================
			virtual void SetBoxInfoInSqlite(const map<gisINT64, vector<double> >& tid2Box) = 0;

			//================================================================================
			/// 结束写入属性到SQLite数据库中
			///
			/// @return 操作结果
			///         - gisLONG > 0：操作成功
			///         - gisLONG <= 0：操作失败
			///
			/// @remark 仅对M3D2.2及以上版本有效，在调用Save()之后调用此方法，
			///         否则不会实际写入到数据库中。仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG EndWriteSqlite() = 0;

			//================================================================================
			/// 获取Tileset详细信息
			///
			/// @return Tileset详细信息对象指针
			///
			/// @remark 返回的对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			virtual G3DTilesetInfo* GetInfo() = 0;

			//================================================================================
			/// 设置结构树信息
			///
			/// @param [in] rootNode 要设置的结构树根节点引用
			///
			/// @return 操作结果
			///         - gisLONG > 0：设置成功
			///         - gisLONG <= 0：设置失败
			///
			/// @remark 仅对M3D2.1及以上版本有效，仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG SetStructureTreeInfo(StructureTreeNode& rootNode) = 0;

			//================================================================================
			/// 获取结构树信息
			///
			/// @param [out] rootNode 用于接收结构树信息的根节点引用
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			///
			/// @remark 仅对M3D2.1及以上版本有效，仅当IsValid()为true时该方法有效
			//================================================================================
			virtual gisLONG GetStructureTreeInfo(StructureTreeNode& rootNode) = 0;
		};


		//================================================================================
		/// 通用工具类
		/// 提供各种静态工具方法，用于处理M3D数据的读写、转换和计算等操作
		//================================================================================
		class MAPGISG3DTILEEXPORT Common
		{
		public:
			//================================================================================
			/// 根据字段名称计算属性字段ID
			///
			/// @param [in] name 字段名称字符串
			///
			/// @return 计算得到的字段ID值
			///
			/// @remark 通过哈希算法根据字段名称生成唯一的字段标识符
			//================================================================================
			static unsigned int API_CalcAttFieldID(CGString name);

			//================================================================================
			/// 根据数据源路径和图层名称计算图层ID
			///
			/// @param [in] dataSource 数据源路径字符串
			/// @param [in] layerName  图层名称字符串
			///
			/// @return 计算得到的图层ID值
			///
			/// @remark 通过哈希算法根据数据源和图层名称生成唯一的图层标识符
			//================================================================================
			static unsigned int API_CalcAttLayerID(CGString dataSource, CGString layerName);

			//================================================================================
			/// 根据源路径和相对路径构造新的完整路径
			///
			/// @param [in] orPath        源路径（基础路径）
			/// @param [in] relativePath  相对路径
			///
			/// @return 构造得到的新路径字符串
			///
			/// @remark 用于路径拼接操作，支持相对路径解析
			//================================================================================
			static CGString API_MakePathByRelativePath(CGString orPath, CGString relativePath);

			//================================================================================
			/// 从glTF数据流中读取模型信息（不考虑实例信息）
			///
			/// @param [in]  byteArray      glTF格式的数据流
			/// @param [in]  pCacheStorage  缓存存储对象指针
			/// @param [out] pModel         用于接收模型信息的G3DModel对象指针
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 仅读取几何模型信息，不处理实例化相关数据
			//================================================================================
			static gisLONG API_ReadGltfContent(const CGByteArray& byteArray, G3DCacheStorage* pCacheStorage, MapGIS::Tile::G3DModel* pModel);

			//================================================================================
			/// 将模型信息写入为glTF数据流
			///
			/// @param [in]  pModel           要写入的模型信息对象指针
			/// @param [in]  pCacheStorage    缓存存储对象指针
			/// @param [in]  geoCompressType  几何数据压缩类型枚举值
			/// @param [in]  idMode           ID写入模式（0:不写ID, 1:写为OID, 2:写为BatchID）
			/// @param [in]  centerDot        数据中心点坐标
			/// @param [out] byteArray        用于接收glTF数据流的字节数组引用
			///
			/// @return 操作结果
			///         - gisLONG > 0：写入成功
			///         - gisLONG <= 0：写入失败
			//================================================================================
			static gisLONG API_WriteGltfContent(MapGIS::Tile::G3DModel* pModel, G3DCacheStorage* pCacheStorage, GeoCompressType geoCompressType, int idMode, D_3DOT centerDot, CGByteArray& byteArray);

			//================================================================================
			/// 从glTF数据流中读取模型信息（不考虑实例信息）
			///
			/// @param [in]  byteArray      glTF格式的数据流
			/// @param [in]  pCacheStorage  缓存存储对象指针
			/// @param [out] pContents      用于接收模型信息的ContentBase对象向量指针（需外部销毁）
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 读取的内容对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static gisLONG API_ReadGltfContent(const CGByteArray& byteArray, G3DCacheStorage* pCacheStorage, vector<ContentBase*>* pContents);

			//================================================================================
			/// 将内容信息写入为glTF数据流
			///
			/// @param [in]  pContents                  要写入的内容信息向量指针
			/// @param [in]  pCacheStorage              缓存存储对象指针
			/// @param [in]  geoCompressType            几何数据压缩类型枚举值
			/// @param [in]  idMode                     ID写入模式（0:不写ID, 1:写为OID, 2:写为BatchID）
			/// @param [in]  addEXT_mesh_gpu_instancing 是否添加GPU实例化扩展
			/// @param [in]  centerDot                  数据中心点坐标
			/// @param [out] byteArray                  用于接收glTF数据流的字节数组引用
			///
			/// @return 操作结果
			///         - gisLONG > 0：写入成功
			///         - gisLONG <= 0：写入失败
			//================================================================================
			static gisLONG API_WriteGltfContent(vector<ContentBase*>* pContents, G3DCacheStorage* pCacheStorage, GeoCompressType geoCompressType, int idMode, bool addEXT_mesh_gpu_instancing, D_3DOT centerDot, CGByteArray& byteArray);

			//================================================================================
			/// 根据文件路径获取M3D瓦片信息
			///
			/// @param [in] path M3D瓦片文件路径（仅支持本地文件路径）
			///
			/// @return M3D瓦片信息对象指针
			///         - 成功：指向G3DM3DTileInfo对象（需外部释放）
			///         - 失败：返回nullptr
			///
			/// @remark 返回的对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static G3DM3DTileInfo* API_GetM3DTileInfo(const CGString& path);

			//================================================================================
			/// 根据文件路径获取M3D瓦片集信息
			///
			/// @param [in] path M3D瓦片集文件路径（仅支持本地文件路径）
			///
			/// @return M3D瓦片集信息对象指针
			///         - 成功：指向G3DM3DTilesetInfo对象（需外部释放）
			///         - 失败：返回nullptr
			///
			/// @remark 返回的对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static G3DM3DTilesetInfo* API_GetM3DTilesetInfo(const CGString& path);

			//================================================================================
			/// 根据数据流获取M3D瓦片信息
			///
			/// @param [in] byteArray M3D瓦片数据流
			///
			/// @return M3D瓦片信息对象指针
			///         - 成功：指向G3DM3DTileInfo对象（需外部释放）
			///         - 失败：返回nullptr
			///
			/// @remark 返回的对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static G3DM3DTileInfo* API_GetM3DTileInfo(const CGByteArray& byteArray);

			//================================================================================
			/// 根据数据流获取M3D瓦片集信息
			///
			/// @param [in] byteArray M3D瓦片集数据流
			///
			/// @return M3D瓦片集信息对象指针
			///         - 成功：指向G3DM3DTilesetInfo对象（需外部释放）
			///         - 失败：返回nullptr
			///
			/// @remark 返回的对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static G3DM3DTilesetInfo* API_GetM3DTilesetInfo(const CGByteArray& byteArray);

			//================================================================================
			/// 根据M3D文件和属性文件路径读取模型内容信息
			///
			/// @param [in]  m3dPath   M3D文件路径
			/// @param [in]  attPath   属性文件路径指针（如果属性文件在外部且需要获取时传入）
			/// @param [out] pContents 用于接收内容信息的ContentBase对象向量指针（需外部释放）
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 读取的内容对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static gisLONG API_ReadM3DContent(const CGString& m3dPath, const CGString* attPath, vector<ContentBase*>* pContents);

			//================================================================================
			/// 根据M3D数据流和属性数据流读取模型内容信息
			///
			/// @param [in]  m3dByteArray   M3D数据流
			/// @param [in]  attByteArray   属性数据流指针（如果属性文件在外部且需要获取时传入）
			/// @param [out] pContents      用于接收内容信息的ContentBase对象向量指针（需外部释放）
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 读取的内容对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static gisLONG API_ReadM3DContent(const CGByteArray& m3dByteArray, const CGByteArray* attByteArray, vector<ContentBase*>* pContents);

			//================================================================================
			/// 根据M3D文件路径获取Content数据流信息
			///
			/// @param [in]  m3dPath       M3D文件路径
			/// @param [out] content       用于接收content数据流的字节数组引用
			/// @param [out] tid           用于接收tid数据流的字节数组引用（M3D 2.1/2.2版本特有）
			/// @param [out] att           用于接收属性数据流的字节数组引用
			/// @param [out] contentType   用于接收content类型的ContentType枚举值引用
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 
			/// - 如果att文件在内部则返回对应数据流
			/// - M3D 2.0版本返回存储属性的JSON流
			/// - M3D 2.1/2.2版本返回att文件流
			/// - contentType支持 M3DGLB, M3DI3DM,M3DPNTS,M3DCMPT 四种类型数据
			//================================================================================
			static gisLONG API_ReadM3DByteArray(const CGString& m3dPath, CGByteArray& content, CGByteArray& tid, CGByteArray& att, ContentType& contentType);

			//================================================================================
			/// 根据M3D数据流获取Content数据流信息
			///
			/// @param [in]  m3d           M3D数据流
			/// @param [out] content       用于接收content数据流的字节数组引用
			/// @param [out] tid           用于接收tid数据流的字节数组引用（M3D 2.1/2.2版本特有）
			/// @param [out] att           用于接收属性数据流的字节数组引用
			/// @param [out] contentType   用于接收content类型的ContentType枚举值引用
			///
			/// @return 操作结果
			///         - gisLONG > 0：读取成功
			///         - gisLONG <= 0：读取失败
			///
			/// @remark 
			/// - 如果att文件在内部则返回对应数据流
			/// - M3D 2.0版本返回存储属性的JSON流
			/// - M3D 2.1/2.2版本返回att文件流
			/// - contentType支持 M3DGLB, M3DI3DM,M3DPNTS,M3DCMPT 四种类型数据
			//================================================================================
			static gisLONG API_ReadM3DByteArray(const CGByteArray& m3d, CGByteArray& content, CGByteArray& tid, CGByteArray& att, ContentType& contentType);

			//================================================================================
			/// 根据数据流读取模型内容信息
			///
			/// @param [in]  content       content数据流
			/// @param [in]  tid           tid信息数据流
			/// @param [in]  att           属性信息数据流
			/// @param [out] pContents     用于接收内容信息的ContentBase对象向量指针（需外部释放）
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 读取的内容对象需要调用者在使用完毕后手动释放内存
			//================================================================================
			static gisLONG API_ByteArrayToContent(const CGByteArray& content, const CGByteArray& tid, const CGByteArray& att, vector<ContentBase*>* pContents);
			
			//================================================================================
			/// 将Content数据流转换为glTF数据流（单输出版本）
			///
			/// @param [in]  content          输入的Content数据流
			/// @param [out] gltfByteArray    输出的glTF数据流
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式（注：m3d_cmpt 转换为1个glTF，后面不能与tid关联）
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_ContentToGltf(const CGByteArray& content, CGByteArray& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将Content数据流转换为glTF数据流（多输出版本）
			///
			/// @param [in]  content          输入的Content数据流
			/// @param [out] gltfByteArray    输出的glTF数据流向量
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式（注：m3d_cmpt会转换为多个）
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_ContentToGltf(const CGByteArray& content, vector<CGByteArray>& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将Content数据流和TID数据流转换为glTF数据流（单输出版本）
			///
			/// @param [in]  content          输入的Content数据流
			/// @param [in]  tid              输入的TID数据流
			/// @param [out] gltfByteArray    输出的glTF数据流
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式（注：m3d_cmpt 转换为1个glTF，后面不能与tid关联）
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_ContentToGltf(const CGByteArray& content, const CGByteArray& tid, CGByteArray& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将Content数据流和TID数据流转换为glTF数据流（多输出版本）
			///
			/// @param [in]  content          输入的Content数据流
			/// @param [in]  tid              输入的TID数据流
			/// @param [out] gltfByteArray    输出的glTF数据流向量
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式（注：m3d_cmpt会转换为多个）
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_ContentToGltf(const CGByteArray& content, const CGByteArray& tid, vector<CGByteArray>& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将M3D文件转换为glTF数据流（单输出版本，路径输入）
			///
			/// @param [in]  m3dPath          M3D文件路径
			/// @param [out] gltfByteArray    输出的glTF数据流
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_M3DToGltf(const CGString& m3dPath, CGByteArray& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将M3D数据流转换为glTF数据流（单输出版本，流输入）
			///
			/// @param [in]  m3d              M3D数据流
			/// @param [out] gltfByteArray    输出的glTF数据流
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_M3DToGltf(const CGByteArray& m3d, CGByteArray& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将M3D文件转换为glTF数据流（多输出版本，路径输入）
			///
			/// @param [in]  m3dPath          M3D文件路径
			/// @param [out] gltfByteArray    输出的glTF数据流向量
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式（注：m3d_cmpt会转换为多个）
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_M3DToGltf(const CGString& m3dPath, vector<CGByteArray>& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 将M3D数据流转换为glTF数据流（多输出版本，流输入）
			///
			/// @param [in]  m3d              M3D数据流
			/// @param [out] gltfByteArray    输出的glTF数据流向量
			/// @param [in]  geoCompressType  几何数据压缩类型
			/// @param [in]  useInstance      是否使用实例化
			///
			/// @return 操作结果
			///         - gisLONG > 0：转换成功
			///         - gisLONG <= 0：转换失败
			///
			/// @remark 
			/// - 支持将 M3DI3DM,M3DPNTS,M3DCMPT 转换为glTF格式（注：m3d_cmpt会转换为多个）
			/// - 支持将带有实例信息的M3DGLB转换为不带实例信息的glb
			//================================================================================
			static gisLONG API_M3DToGltf(const CGByteArray& m3d, vector<CGByteArray>& gltfByteArray, GeoCompressType geoCompressType, bool useInstance);

			//================================================================================
			/// 从属性文件流中获取属性信息
			///
			/// @param [in]  byteArray  属性数据流，支持JSON格式或ATT格式的流文件
			/// @param [out] att        输出的属性内容
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			//================================================================================
			static gisLONG API_GetAttribute(const CGByteArray& byteArray, Attribute& att);

			//================================================================================
			/// 从SQLite数据库流中获取属性信息
			///
			/// @param [in]  byteArray  SQLite数据库流
			/// @param [out] att        输出的属性内容
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			//================================================================================
			static gisLONG API_GetAttributeBySqlite(const CGByteArray& byteArray, Attribute& att);

			//================================================================================
			/// 从SQLite数据库文件路径中获取属性信息
			///
			/// @param [in]  sqlitePath SQLite数据库文件路径
			/// @param [out] att        输出的属性内容
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			//================================================================================
			static gisLONG API_GetAttributeBySqlite(const CGString& sqlitePath, Attribute& att);

			//================================================================================
			/// 从TID数据流中获取TID信息
			///
			/// @param [in]  byteArray  TID数据流
			/// @param [out] tid        输出的TID信息向量
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			//================================================================================
			static gisLONG API_GetTid(const CGByteArray& byteArray, vector<vector<gisINT64>>& tid);

			//================================================================================
			/// 获取构件树信息（基于文件系统路径）
			///
			/// @param [in]  path  构件树根路径
			/// @param [out] tree  输出的构件树信息根节点
			///
			/// @return 操作结果
			///         - gisLONG > 0：获取成功
			///         - gisLONG <= 0：获取失败
			///
			/// @remark 构件树内部组织使用相对路径，不支持内存流解析
			//================================================================================
			static gisLONG API_GetStructureTree(const CGString& path, StructureTreeNode& tree);
		};
	}
}

#endif